/* istanbul ignore file */
/* tslint:disable */
/* eslint-disable */
import type { ApiRequestOptions } from "./ApiRequestOptions";
import type { ApiResult } from "./ApiResult";
import { Config } from "./OpenAPI";

const contentType = "Content-Type";
const contentTypeJson = "application/json";

function isDefined<T>(value: T | null | undefined): value is Exclude<T, null | undefined> {
  return value !== undefined && value !== null;
}

function isStringWithValue(value: any): value is string {
  return typeof value === "string" && value !== "";
}

function getQueryString(params: Record<string, any>): string {
  const qs: string[] = [];
  Object.keys(params).forEach(key => {
    const value = params[key];
    if (isDefined(value)) {
      if (Array.isArray(value)) {
        value.forEach(value => {
          qs.push(`${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`);
        });
      } else {
        qs.push(`${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`);
      }
    }
  });
  if (qs.length > 0) {
    return `?${qs.join("&")}`;
  }
  return "";
}

function getUrl(config: Config, options: ApiRequestOptions): string {
  const path = options.path.replace(/[:]/g, "_");
  const url = `${config.BASE}${path}`;

  if (options.query) {
    return `${url}${getQueryString(options.query)}`;
  }
  return url;
}

type Resolver<T> = (options: ApiRequestOptions) => Promise<T>;

async function resolve<T>(options: ApiRequestOptions, resolver?: T | Resolver<T>): Promise<T | undefined> {
  if (typeof resolver === "function") {
    return (resolver as Resolver<T>)(options);
  }
  return resolver;
}

async function getHeaders(config: Config, options: ApiRequestOptions): Promise<Headers> {
  const username = await resolve(options, config.USERNAME);
  const password = await resolve(options, config.PASSWORD);
  const defaultHeaders = await resolve(options, config.HEADERS);

  const headers = new Headers({
    Accept: contentTypeJson,
    ...defaultHeaders,
    ...options.headers
  });

  if (isStringWithValue(username) && isStringWithValue(password)) {
    const credentials = btoa(`${username}:${password}`);
    headers.append("Authorization", `Basic ${credentials}`);
  }

  if (options.body) {
    headers.append(contentType, contentTypeJson);
  }

  return headers;
}

function getRequestBody(options: ApiRequestOptions): any {
  if (options.body) {
    return JSON.stringify(options.body);
  }
  return undefined;
}

async function sendRequest(config: Config, options: ApiRequestOptions, url: string): Promise<XMLHttpRequest> {
  const xhr = new XMLHttpRequest();
  xhr.open(options.method, url, true);
  xhr.withCredentials = config.WITH_CREDENTIALS;

  const headers = await getHeaders(config, options);
  headers.forEach((value: string, key: string) => {
    xhr.setRequestHeader(key, value);
  });

  return new Promise<XMLHttpRequest>(resolve => {
    xhr.onreadystatechange = () => {
      if (xhr.readyState === XMLHttpRequest.DONE) {
        resolve(xhr);
      }
    };
    xhr.send(getRequestBody(options));
  });
}

function getResponseHeader(xhr: XMLHttpRequest, responseHeader?: string): string | null {
  if (responseHeader) {
    return xhr.getResponseHeader(responseHeader);
  }
  return null;
}

function getResponseBody(xhr: XMLHttpRequest): any {
  const headerValue = xhr.getResponseHeader(contentType);
  if (headerValue) {
    const isJSON = headerValue.toLowerCase().startsWith(contentTypeJson);
    if (isJSON) {
      return JSON.parse(xhr.responseText);
    } else {
      return xhr.responseText;
    }
  }
  return null;
}

/**
 * Request using XHR client
 * @param options The request options from the the service
 * @returns ApiResult
 * @throws ApiError
 */
export async function request<T>(config: Config, options: ApiRequestOptions): Promise<ApiResult<T>> {
  const url = getUrl(config, options);
  const response = await sendRequest(config, options, url);
  const responseBody = getResponseBody(response);
  const responseHeader = getResponseHeader(response, options.responseHeader);

  return {
    url,
    ok: response.status >= 200 && response.status < 300,
    status: response.status,
    statusText: response.statusText,
    body: responseHeader || responseBody
  };
}
